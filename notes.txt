>dotnet new webapi -o src/AuctionService -controllers
>dotnet new webapi -o src/SearchService -controllers
>dotnet sln add src/Contracts
>docker compose up -d => run docker
>when a service is registered in program cs it can be injected anywhere
>make a http client that fetch new data from auction service
==FOR SYNCRONOUS DATA PASSING BETWEEN DB==
>polling - repeating request until it succeeds => microsoft.extensions.http.polly
==FOR ASYNCRONOUS DATA PASSING BETWEEN DB==
> using a event bus RabbitMQ
>using masstransit to abstract the rabbit and services connection
> making new class library to avoid copy pasting:  dotnet new classlib -o src/Contracts
>adding as refernce : dotnet add reference ../../src/Contracts/
>Contracts = DTO
>contracts will be the dto that will be the middleman between services
>we need Class LIbraru=y because masstransit need to have contracts in the same namespace/directory
>setup consumers in services that needs to be updated like SearchService
>when consuming, map the consumerdto/servicebusdto to the local entity of the service
>when publishing, map the local dto/entity to the servicebus dto