>dotnet new webapi -o src/AuctionService -controllers
>dotnet new webapi -o src/SearchService -controllers
>dotnet sln add src/Contracts
>docker compose up -d => run docker
>when a service is registered in program cs it can be injected anywhere
>make a http client that fetch new data from auction service
==FOR SYNCRONOUS DATA PASSING BETWEEN DB==
>polling - repeating request until it succeeds => microsoft.extensions.http.polly
==FOR ASYNCRONOUS DATA PASSING BETWEEN DB==
> using a event bus RabbitMQ
>using masstransit to abstract the rabbit and services connection
> making new class library to avoid copy pasting:  dotnet new classlib -o src/Contracts
>adding as refernce : dotnet add reference ../../src/Contracts/
>Contracts = DTO
>contracts will be the dto that will be the middleman between services
>we need Class LIbraru=y because masstransit need to have contracts in the same namespace/directory
>setup consumers in services that needs to be updated like SearchService
>when consuming, map the consumerdto/servicebusdto to the local entity of the service
>when publishing, map the local dto/entity to the servicebus dto
>the consumer will automatically consume same dto, just need to setup consumers the automap and put it in service in program cs and its already okay
>use outbox for failed consumes, it will store the failed requests
>masstransit.entityframeworkcore nuget to use the outbox, it should be the same version as the masstransit
>install the masstransit.entityframeworkcore to the publishers
>REMEMBER if something in transaction in entity controller fails like sorting, filtering, saving, the entire process fails
>that means masstransit.entityframeworkcore is IMPORTANT since it will INCLUDE MASSTRANSIT to a transaction
>that means if publish fails, db saving fails, vice versa preventing not synced db
> because of outbox If SaveChangesAsync() fails, the event never reaches RabbitMQ.
> implement masstransit messageretry so that if a consume failed
>if the consumer throws an error it is loaded in service bus which can be consumed by the publisher to know whats the problem and decide if to rollback
> make another consumer in publisher servce to listen to the fault /error messages or items that causes system exceptiom
> use the fault consumer to try to fix problems then publish it again

===to make a new service pub,consumer====
>modify mapper in consumer, map the local dto to service bus dto
>include the publish to the controller
>go to the consumer service
>add consumer file
>map the service bus dto to local dto if necessary
>or you can just make a Entity object like new instance of entity replacing the contents with dto content
>add the retry feature in the program cs masstransit service
