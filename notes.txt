>dotnet new webapi -o src/AuctionService -controllers
>dotnet new webapi -o src/SearchService -controllers
>dotnet sln add src/Contracts
>docker compose up -d => run docker
>when a service is registered in program cs it can be injected anywhere
>make a http client that fetch new data from auction service
==FOR SYNCRONOUS DATA PASSING BETWEEN DB==
>polling - repeating request until it succeeds => microsoft.extensions.http.polly
==FOR ASYNCRONOUS DATA PASSING BETWEEN DB==
> using a event bus RabbitMQ
>using masstransit to abstract the rabbit and services connection
> making new class library to avoid copy pasting:  dotnet new classlib -o src/Contracts
>adding as refernce : dotnet add reference ../../src/Contracts/
>Contracts = DTO
>contracts will be the dto that will be the middleman between services
>we need Class LIbraru=y because masstransit need to have contracts in the same namespace/directory
>setup consumers in services that needs to be updated like SearchService
>when consuming, map the consumerdto/servicebusdto to the local entity of the service
>when publishing, map the local dto/entity to the servicebus dto
>the consumer will automatically consume same dto
>use outbox for failed consumes, it will store the failed requests
>masstransit.entityframeworkcore nuget to use the outbox, it should be the same version as the masstransit
>install the masstransit.entityframeworkcore to the publishers
>REMEMBER if something in transaction in entity controller fails like sorting, filtering, saving, the entire process fails
>that means masstransit.entityframeworkcore is IMPORTANT since it will INCLUDE MASSTRANSIT to a transaction
>that means if publish fails, db saving fails, vice versa
> because of outbox If SaveChangesAsync() fails, the event never reaches RabbitMQ.