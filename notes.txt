>dotnet new webapi -o src/AuctionService -controllers
>dotnet new webapi -o src/SearchService -controllers
>dotnet sln add src/Contracts
>docker compose up -d => run docker
>when a service is registered in program cs it can be injected anywhere
>make a http client that fetch new data from auction service
==FOR SYNCRONOUS DATA PASSING BETWEEN DB==
>polling - repeating request until it succeeds => microsoft.extensions.http.polly
==FOR ASYNCRONOUS DATA PASSING BETWEEN DB==
> using a event bus RabbitMQ
>using masstransit to abstract the rabbit and services connection
> making new class library to avoid copy pasting:  dotnet new classlib -o src/Contracts
>adding as refernce : dotnet add reference ../../src/Contracts/
>Contracts = DTO
>contracts will be the dto that will be the middleman between services
>we need Class LIbraru=y because masstransit need to have contracts in the same namespace/directory
>setup consumers in services that needs to be updated like SearchService
>when consuming, map the consumerdto/servicebusdto to the local entity of the service
>when publishing, map the local dto/entity to the servicebus dto
>the consumer will automatically consume same dto, just need to setup consumers the automap and put it in service in program cs and its already okay
>use outbox for failed consumes, it will store the failed requests
>masstransit.entityframeworkcore nuget to use the outbox, it should be the same version as the masstransit
>install the masstransit.entityframeworkcore to the publishers
>REMEMBER if something in transaction in entity controller fails like sorting, filtering, saving, the entire process fails
>that means masstransit.entityframeworkcore is IMPORTANT since it will INCLUDE MASSTRANSIT to a transaction
>that means if publish fails, db saving fails, vice versa preventing not synced db
> because of outbox If SaveChangesAsync() fails, the event never reaches RabbitMQ.
> implement masstransit messageretry so that if a consume failed
>if the consumer throws an error it is loaded in service bus which can be consumed by the publisher to know whats the problem and decide if to rollback
> make another consumer in publisher servce to listen to the fault /error messages or items that causes system exceptiom
> use the fault consumer to try to fix problems then publish it again

===to make a new service pub,consumer====
>modify mapper in consumer, map the local dto to service bus dto
>include the publish to the controller
>go to the consumer service
>add consumer file
>map the service bus dto to local dto if necessary
>or you can just make a Entity object like new instance of entity replacing the contents with dto content
>add the retry feature in the program cs masstransit service

====Identity server====
>identity store user data
>user use client(the webapp)
>client will redirect the browser to the identity server
>the request includes client ID, redirect URL(the homepage after logging in), response type, etc
>identity verifies u based on client id, if no session then u need to login
>if you have session then it will just return the token
>if not, then you need to login then identity will pass auth code to browser
>identity calls the redirect url provided to the client
>the client will contact identity directly with auth code, client id, secrets
>identity will return access token to client
>use token to access services


===after making identity server auth====
>it only allows user to access the protected webpage of identity server
>cookie based auth
>it doesnt include api or apps outside the identity server
>thats why after identity server auth, it will request a token that will be given to the client to access apis

Hereâ€™s how the flow works when you use IdentityServer with a separate authentication server:

Step 1: User Accesses Your Web App
A user opens your web app (which could be a React, Angular, or any other frontend app).
The web app wants to authenticate the user to verify their identity, so it redirects the user to the IdentityServer (which is the authentication server).
Step 2: User Logs In via IdentityServer
The user logs in on IdentityServer (the separate server). This could be a simple login form or something more complex, depending on the flow (password-based login, social login, etc.).
If the login is successful, IdentityServer will issue an authentication token (usually an ID token and an access token), and the user will be redirected back to the original web app with these tokens.
Step 3: User is Redirected Back to Web App
After successful authentication, the user is redirected back to your web app, along with the tokens.
Your web app (or frontend) can now use these tokens to access protected resources like an API, or even personalize the user experience, because the token confirms the user's identity.
Step 4: Accessing the Protected API (if applicable)
If your web app needs to make calls to a protected API (for example, to retrieve user-specific data), it can send the access token in the request headers (e.g., in the Authorization header) to authenticate the user.